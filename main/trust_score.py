# -*- coding: utf-8 -*-
"""Trust score.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LVQv73tDz_G02yx_dRkoyji79K_yXo91
"""

import pandas as pd
import numpy as np

def convert_to_trust_matrix(adjacency_matrix):
    # Convert the adjacency matrix to a NumPy array
    adj_matrix_array = np.array(adjacency_matrix.iloc[1:, 1:], dtype=float)

    # Calculate the trust matrix
    trust_matrix = adj_matrix_array / adj_matrix_array.sum(axis=1, keepdims=True)

    # Replace NaN values with 0 (for nodes with no adjacent nodes)
    trust_matrix = np.nan_to_num(trust_matrix)

    return trust_matrix

# Example usage for the department layer
dept_adj_matrix = pd.read_csv("/content/Dept_IntraLayer_AdjcMatrix.csv")
trust_matrix_dept = convert_to_trust_matrix(dept_adj_matrix)

print("Trust Matrix for the Department Layer:")
print(trust_matrix_dept)

hosp_adj_matrix = pd.read_csv("/content/Hospt_IntraLayer_AdjcMatrix.csv")
trust_matrix_hosp = convert_to_trust_matrix(hosp_adj_matrix)

print("Trust Matrix for the Hospital Layer:")
print(trust_matrix_hosp)

hosp_dept_adj_matrix = pd.read_csv("/content/HospDept_InterLayer_AdjcMatrix.csv")
trust_matrix_hosp_dept = convert_to_trust_matrix(hosp_dept_adj_matrix)

print("Trust Matrix for the Hospital- Department Layer:")
print(trust_matrix_hosp_dept)

doct_adj_matrix = pd.read_csv("/content/Doct_IntraLayer_AdjcMatrix.csv")
trust_matrix_doct = convert_to_trust_matrix(doct_adj_matrix)

print("Trust Matrix for the Doctor Layer:")
print(trust_matrix_doct)

dept_doct_adj_matrix = pd.read_csv("/content/DeptDoct_InterLayer_AdjcMatrix.csv")
trust_matrix_dept_doct = convert_to_trust_matrix(dept_doct_adj_matrix)

print("Trust Matrix for the Department- Doctor Layer:")
print(trust_matrix_dept_doct)

import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from scipy.interpolate import make_interp_spline
from sklearn.preprocessing import MinMaxScaler

# Function to create a line chart with a small box plot
def plot_department_trust(trust_scores, title, filename):
    fig, ax1 = plt.subplots(figsize=(9, 6))

    # Create bins with an increase of 0.025
    bins = np.arange(0, 1.1, 0.025)
    hist, bin_edges = np.histogram(trust_scores, bins=bins)

    # Smooth the line using spline interpolation
    bin_centers = 0.5 * (bin_edges[1:] + bin_edges[:-1])
    spline = make_interp_spline(bin_centers, hist, k=3)
    bin_centers_smooth = np.linspace(bin_centers.min(), bin_centers.max(), 300)
    hist_smooth = spline(bin_centers_smooth)

    # Line chart with smoothed curve
    ax1.plot(bin_centers_smooth, hist_smooth, label='Line Chart', color='skyblue')

    # Add labels and title for the line chart
    ax1.set_xlabel('Trust Score')
    ax1.set_ylabel('Frequency')
    ax1.set_title(title)

    # Scale the trust_scores for box plot
    scaler = MinMaxScaler()
    trust_scores_scaled = scaler.fit_transform(trust_scores.reshape(-1, 1)).flatten()

    # Create a second axis for the box plot in the top-right corner
    ax2 = ax1.inset_axes([0.6, 0.6, 0.35, 0.35], transform=ax1.transAxes)  # [x, y, width, height]

    # Box plot (vertical)
    sns.boxplot(y=trust_scores_scaled, ax=ax2, color='skyblue', orient='v')
    ax2.set_title('Box Plot')
    ax2.set_xticks([])  # Remove x-axis ticks

    # Save the plot as a PDF file
    plt.savefig(filename)
    plt.close(fig)

# Assuming trust_matrix_dept, trust_matrix_doct, and trust_matrix_hosp are defined
plot_department_trust(trust_matrix_dept.flatten(), 'Department Trust Score Distribution', 'Department_Trust_Score_Distribution.pdf')
plot_department_trust(trust_matrix_doct.flatten(), 'Doctor Trust Score Distribution', 'Doctor_Trust_Score_Distribution.pdf')
plot_department_trust(trust_matrix_hosp.flatten(), 'Hospital Trust Score Distribution', 'Hospital_Trust_Score_Distribution.pdf')



import numpy as np

# Set seed for reproducibility
np.random.seed(42)

# Number of departments and hospitals
num_dept = 33
num_hosp = 10

# Initial residual social scores (uniform distribution with initial value 0.2)
residual_social_score_dept = np.full((1, num_dept), 0.2)
residual_social_score_hosp = np.full((1, num_hosp), 0.2)

# Redefine residual social scores for each scenario

# Scenario 1: Normal distribution range (0-1)
residual_social_score_dept_scenario1 = np.random.normal(loc=0.5, scale=0.25, size=(1, num_dept))
residual_social_score_hosp_scenario1 = np.random.normal(loc=0.5, scale=0.25, size=(1, num_hosp))

# Scenario 2: Skewed distribution range (0-1)
residual_social_score_dept_scenario2 = np.random.gamma(2, scale=0.5, size=(1, num_dept))
residual_social_score_hosp_scenario2 = np.random.gamma(2, scale=0.5, size=(1, num_hosp))

# Display the redefined scores for each scenario
print("Scenario 0 - Residual Social Scores (Uniform Distribution):")
print("Department Scores:", residual_social_score_dept)
print("Hospital Scores:", residual_social_score_hosp)

print("\nScenario 1 - Residual Social Scores (Normal Distribution):")
print("Department Scores:", residual_social_score_dept_scenario1)
print("Hospital Scores:", residual_social_score_hosp_scenario1)

print("\nScenario 2 - Residual Social Scores (Skewed Distribution):")
print("Department Scores:", residual_social_score_dept_scenario2)
print("Hospital Scores:", residual_social_score_hosp_scenario2)

# Impute one column with zeros
new_column = np.zeros((10, 2))  # Forcefully setting it to 10 rows

# Pad the original matrix with zeros to make the rows match
trust_matrix_hosp_dept_padded = np.pad(trust_matrix_hosp_dept, ((0, 1), (0, 0)), mode='constant', constant_values=0)

# Check the shapes before concatenation
print("Original Shape:", trust_matrix_hosp_dept.shape)
print("New Column Shape:", new_column.shape)

# Concatenate forcefully
trust_matrix_hosp_dept_extended = np.concatenate((trust_matrix_hosp_dept_padded, new_column), axis=1)

# Check the new shape
print("Extended Shape:", trust_matrix_hosp_dept_extended.shape)
# Print shapes for debugging
print("Trust Matrix Hospital to Department Shape:", trust_matrix_hosp_dept.shape)
print("adj Matrix Hospital to Department Shape:", hosp_dept_adj_matrix.shape)

print("Trust Matrix Department to Doctor Shape:", trust_matrix_dept_doct.shape)
print("Trust Matrix Doctor Shape:", trust_matrix_doct.shape)
print("Trust Matrix Department: ", trust_matrix_dept.shape)

# Pad the original matrix with zeros to make it 10x10
trust_matrix_hosp_padded = np.pad(trust_matrix_hosp, ((0, 1), (0, 0)), mode='constant', constant_values=0)

# Check the new shape
print("Padded Trust Dept Shape:", trust_matrix_hosp_padded.shape)
print("Trust dept Shape:", trust_matrix_hosp.shape)

def estimate_social_score(delta_alpha, delta_beta, tau_beta_alpha, tau_alpha, tolerance=0.001):
    # Initialize social score
    social_score = delta_alpha + np.dot(delta_beta, tau_beta_alpha.T)
    iteration = 0

    while True:
        iteration += 1
        # Update social score using recurrence relation
        social_score_next = np.dot(social_score, tau_alpha)

        # Calculate difference between current and next social score
        gamma = social_score_next - social_score

        if np.all(np.abs(gamma) <= tolerance):
            break

        social_score = social_score_next

    return social_score



# Estimate social score for Hospital uniform 0.2
social_score_hosp = estimate_social_score(residual_social_score_hosp, residual_social_score_dept, trust_matrix_hosp_dept_extended, trust_matrix_hosp_padded)
print("Social Score for Hospital:", social_score_hosp)

# Estimate social score for Hospital normal
social_score_hosp_normal = estimate_social_score(residual_social_score_hosp_scenario1, residual_social_score_dept_scenario1, trust_matrix_hosp_dept_extended, trust_matrix_hosp_padded)
print("Social Score for Hospital (Normal):", social_score_hosp_normal)

# Estimate social score for Hospital skewed
social_score_hosp_skewed = estimate_social_score(residual_social_score_hosp_scenario2, residual_social_score_dept_scenario2, trust_matrix_hosp_dept_extended, trust_matrix_hosp_padded)
print("Social Score for Hospital (Skewed):", social_score_hosp_skewed)

hosp_rating = pd.read_csv("/content/Hosp_Rating.csv")

import numpy as np
from sklearn.preprocessing import MinMaxScaler, StandardScaler

# Your two distributions
distribution1 = np.array([4.5, 3.5, 4.1, 4.5, 5.0, 4.5, 3.0, 4.0, 4.5, 3.5])
distribution2 = np.array([0.005197583505023277, 0.009935585076776497, 0.0036382309136434522, 0.008524865527445297,
                          0.003859638024343117, 0.010439414519814696, 0.0035591567834795984, 0.006423756187395213,
                          0.00034838678671878203, 0.005121189385023298])

# Min-Max Scaling (Normalization)
min_max_scaler = MinMaxScaler()
scaled_distribution1 = min_max_scaler.fit_transform(distribution1.reshape(-1, 1)).flatten()
scaled_distribution2 = min_max_scaler.fit_transform(distribution2.reshape(-1, 1)).flatten()

print("Min-Max Scaled Distribution 1:", scaled_distribution1)
print("Min-Max Scaled Distribution 2:", scaled_distribution2)

# Z-Score Standardization
standard_scaler = StandardScaler()
standardized_distribution1 = standard_scaler.fit_transform(distribution1.reshape(-1, 1)).flatten()
standardized_distribution2 = standard_scaler.fit_transform(distribution2.reshape(-1, 1)).flatten()

print("\nZ-Score Standardized Distribution 1:", standardized_distribution1)
print("Z-Score Standardized Distribution 2:", standardized_distribution2)

import numpy as np
from sklearn.preprocessing import MinMaxScaler, StandardScaler

distribution2_normal = np.array(social_score_hosp_normal)

scaled_distribution2_normal = min_max_scaler.fit_transform(distribution2_normal.reshape(-1, 1)).flatten()

print("Min-Max Scaled Distribution 2 (Normal):", scaled_distribution2_normal)

# Z-Score Standardization
standard_scaler = StandardScaler()
standardized_distribution2_normal = standard_scaler.fit_transform(distribution2_normal.reshape(-1, 1)).flatten()

print("Z-Score Standardized Distribution 2:", standardized_distribution2_normal)

import numpy as np
from sklearn.preprocessing import MinMaxScaler, StandardScaler

distribution2_skewed = np.array(social_score_hosp_skewed)

scaled_distribution2_skewed = min_max_scaler.fit_transform(distribution2_skewed.reshape(-1, 1)).flatten()

print("Min-Max Scaled Distribution 2 (Normal):", scaled_distribution2_skewed)

# Z-Score Standardization
standard_scaler = StandardScaler()
standardized_distribution2_skewed = standard_scaler.fit_transform(distribution2_skewed.reshape(-1, 1)).flatten()

print("Z-Score Standardized Distribution 2:", standardized_distribution2_skewed)

import matplotlib.pyplot as plt
import seaborn as sns

def plot_distribution_with_boxplot(data, title, filename):
    fig, ax = plt.subplots(figsize=(9, 6))

    # Create the histogram
    sns.histplot(data, bins=20, kde=True, color='blue', ax=ax)
    ax.set_title(title)

    # Create a second axis for the box plot in the top-left corner
    ax_box = ax.inset_axes([0.05, 0.7, 0.16, 0.18], transform=ax.transAxes)  # Adjusted position coordinates
    sns.boxplot(y=data, ax=ax_box, color='orange', orient='v')  # orient='v' for vertical
    ax_box.set_title('Box Plot')
    ax_box.set_xticks([])  # Remove x-axis ticks

    # Save the plot as a PDF file
    plt.savefig(filename)
    plt.close(fig)

# Save each plot as a separate PDF
plot_distribution_with_boxplot(standardized_distribution1, 'Z-score Standardized Hospital Rating', 'Z_score_Standardized_Hospital_Rating.pdf')
plot_distribution_with_boxplot(standardized_distribution2, 'Z-score Standardized Hospital Social Score (Uniform)', 'Z_score_Standardized_Hospital_Social_Score_Uniform.pdf')
plot_distribution_with_boxplot(scaled_distribution1, 'Min-Max Scaled Hospital Rating', 'Min_Max_Scaled_Hospital_Rating.pdf')
plot_distribution_with_boxplot(scaled_distribution2, 'Min-Max Scaled Hospital Social Score (Uniform)', 'Min_Max_Scaled_Hospital_Social_Score_Uniform.pdf')
plot_distribution_with_boxplot(standardized_distribution1, 'Z-score Standardized Hospital Rating', 'Z_score_Standardized_Hospital_Rating_2.pdf')
plot_distribution_with_boxplot(standardized_distribution2_skewed, 'Z-score Standardized Hospital Social Score (Normal)', 'Z_score_Standardized_Hospital_Social_Score_Normal.pdf')

from scipy.stats import wasserstein_distance

# Calculate Wasserstein Distance
w_distance = wasserstein_distance(scaled_distribution1, scaled_distribution2)
print(f'Wasserstein Distance Scaled: {w_distance}')

# Calculate Wasserstein Distance
w_distance = wasserstein_distance(distribution1, distribution2)
print(f'Wasserstein Distance Unscaled: {w_distance}')

from scipy.stats import spearmanr

# Compute Spearman correlation between the two distributions
spearman_corr, p_value = spearmanr(standardized_distribution1, standardized_distribution2)

print("Spearman correlation coefficient:", round(spearman_corr,3))
print("p-value:", round(p_value,3))

from scipy.stats import spearmanr

# Compute Spearman correlation between the two distributions
spearman_corr, p_value = spearmanr(scaled_distribution1, scaled_distribution2_normal)

print("Spearman correlation coefficient:", spearman_corr)
print("p-value:", p_value)

"""Weak relationship

### JOYDEEP you can start from here and copy the code from above.... dont remove the top results
"""

import numpy as np

# Set seed for reproducibility
np.random.seed(42)

# Number of departments and hospitals
num_dept = 33
num_doc = 77

# Initial residual social scores (uniform distribution with initial value 0.2)
residual_social_score_dept = np.full((1, num_dept), 0.2)
residual_social_score_doc = np.full((1, num_doc), 0.2)

# Redefine residual social scores for each scenario

# Scenario 1: Normal distribution range (0-1)
residual_social_score_dept_scenario1 = np.random.normal(loc=0.5, scale=0.25, size=(1, num_dept))
residual_social_score_doc_scenario1 = np.random.normal(loc=0.5, scale=0.25, size=(1, num_doc))

# Scenario 2: Skewed distribution range (0-1)
residual_social_score_dept_scenario2 = np.random.gamma(2, scale=0.5, size=(1, num_dept))
residual_social_score_doc_scenario2 = np.random.gamma(2, scale=0.5, size=(1, num_doc))

# Display the redefined scores for each scenario
print("Scenario 0 - Residual Social Scores (Uniform Distribution):")
print("Department Scores:", residual_social_score_dept)
print("Doctor Scores:", residual_social_score_doc)

print("\nScenario 1 - Residual Social Scores (Normal Distribution):")
print("Department Scores:", residual_social_score_dept_scenario1)
print("Doctor Scores:", residual_social_score_doc_scenario1)

print("\nScenario 2 - Residual Social Scores (Skewed Distribution):")
print("Department Scores:", residual_social_score_dept_scenario2)
print("Doctor Scores:", residual_social_score_doc_scenario2)

print("Trust Matrix Department: ", residual_social_score_doc.shape)

print("Trust Matrix Department to Doctor Shape:", trust_matrix_dept_doct.shape)
print("Trust Matrix Doctor Shape:", trust_matrix_doct.shape)
print("Trust Matrix Department: ", trust_matrix_dept.shape)

import numpy as np

# Reshape the trust matrix to 1x33
if trust_matrix_dept_doct.size >= 33:
    trust_matrix_dept_doct_reshaped = trust_matrix_dept_doct[:, :33]
else:
    raise ValueError("Not enough elements to reshape to (1, 33)")

print("Trust Matrix Department to Doctor Shape after reshaping:", trust_matrix_dept_doct_reshaped.shape)

import numpy as np


# Check the current shape
print("Original Trust Matrix Doctor Shape:", trust_matrix_doct.shape)

# Pad the matrix to make it 77x77
trust_matrix_doct_padded = np.pad(trust_matrix_doct, ((0, 1), (0, 0)), mode='constant', constant_values=0)

# Check the new shape
print("Padded Trust Matrix Doctor Shape:", trust_matrix_doct_padded.shape)

# Output the padded matrix for verification
print(trust_matrix_doct_padded)

def estimate_social_score(delta_alpha, delta_beta, tau_beta_alpha, tau_alpha, tolerance=0.001):
    # Initialize social score
    social_score = delta_alpha + np.dot(delta_beta, tau_beta_alpha.T)
    iteration = 0

    while True:
        iteration += 1
        # Update social score using recurrence relation
        social_score_next = np.dot(social_score, tau_alpha)

        # Calculate difference between current and next social score
        gamma = social_score_next - social_score

        if np.all(np.abs(gamma) <= tolerance):
            break

        social_score = social_score_next

    return social_score



# Estimate social score for Hospital uniform 0.2
social_score_doc = estimate_social_score(residual_social_score_doc, residual_social_score_dept, trust_matrix_dept_doct_reshaped, trust_matrix_doct_padded)
print("Social Score for Doctor:", social_score_doc)

# Estimate social score for Hospital normal
social_score_doc_normal = estimate_social_score(residual_social_score_doc_scenario1, residual_social_score_dept_scenario1, trust_matrix_dept_doct_reshaped, trust_matrix_doct_padded)
print("Social Score for Doctor (Normal):", social_score_doc_normal)

# Estimate social score for Hospital skewed
social_score_doc_skewed = estimate_social_score(residual_social_score_doc_scenario2, residual_social_score_dept_scenario2, trust_matrix_dept_doct_reshaped, trust_matrix_doct_padded)
print("Social Score for Doctor (Skewed):", social_score_doc_skewed)

doct_rating = pd.read_csv("/content/DoctRating.csv")

import numpy as np
from sklearn.preprocessing import MinMaxScaler, StandardScaler

# Your two distributions
distribution1 = np.array(doct_rating['Doct_Rating'])
distribution2 = np.array(social_score_doc)

# Min-Max Scaling (Normalization)
min_max_scaler = MinMaxScaler()
scaled_distribution1 = min_max_scaler.fit_transform(distribution1.reshape(-1, 1)).flatten()
scaled_distribution2 = min_max_scaler.fit_transform(distribution2.reshape(-1, 1)).flatten()

print("Min-Max Scaled Distribution 1:", scaled_distribution1)
print("Min-Max Scaled Distribution 2:", scaled_distribution2)

# Z-Score Standardization
standard_scaler = StandardScaler()
standardized_distribution1 = standard_scaler.fit_transform(distribution1.reshape(-1, 1)).flatten()
standardized_distribution2 = standard_scaler.fit_transform(distribution2.reshape(-1, 1)).flatten()

print("\nZ-Score Standardized Distribution 1:", standardized_distribution1)
print("Z-Score Standardized Distribution 2:", standardized_distribution2)

import numpy as np
from sklearn.preprocessing import MinMaxScaler, StandardScaler

distribution2_normal = np.array(social_score_doc_normal)

scaled_distribution2_normal = min_max_scaler.fit_transform(distribution2_normal.reshape(-1, 1)).flatten()

print("Min-Max Scaled Distribution 2 (Normal):", scaled_distribution2_normal)

# Z-Score Standardization
standard_scaler = StandardScaler()
standardized_distribution2_normal = standard_scaler.fit_transform(distribution2_normal.reshape(-1, 1)).flatten()

print("Z-Score Standardized Distribution 2:", standardized_distribution2_normal)

import numpy as np
from sklearn.preprocessing import MinMaxScaler, StandardScaler

distribution2_skewed = np.array(social_score_doc_skewed)

scaled_distribution2_skewed = min_max_scaler.fit_transform(distribution2_skewed.reshape(-1, 1)).flatten()

print("Min-Max Scaled Distribution 2 (skewed):", scaled_distribution2_skewed)

# Z-Score Standardization
standard_scaler = StandardScaler()
standardized_distribution2_skewed = standard_scaler.fit_transform(distribution2_skewed.reshape(-1, 1)).flatten()

print("Z-Score Standardized Distribution 2 (Skewed):", standardized_distribution2_skewed)

import matplotlib.pyplot as plt
import seaborn as sns

def plot_distribution_with_boxplot(data, title, filename):
    fig, ax = plt.subplots(figsize=(9, 6))

    # Create the histogram
    sns.histplot(data, bins=20, kde=True, color='blue', ax=ax)
    ax.set_title(title)

    # Create a second axis for the box plot in the top-left corner
    ax_box = ax.inset_axes([0.3, 0.7, 0.18, 0.19], transform=ax.transAxes)  # Adjusted position coordinates
    sns.boxplot(y=data, ax=ax_box, color='orange', orient='v')  # orient='v' for vertical
    ax_box.set_title('Box Plot')
    ax_box.set_xticks([])  # Remove x-axis ticks

    # Save the plot as aPDF file
    plt.savefig(filename)
    plt.close(fig)

# Save each plot as a separate PDF
plot_distribution_with_boxplot(standardized_distribution1, 'Z-score Standardized Doctor Rating', 'Z_score_Standardized_Doctor_Rating.pdf')
plot_distribution_with_boxplot(standardized_distribution2, 'Z-score Standardized Doctor Social Score (Uniform)', 'Z_score_Standardized_Doctor_Social_Score_Uniform.pdf')
plot_distribution_with_boxplot(scaled_distribution1, 'Min-Max Scaled Doctor Rating', 'Min_Max_Scaled_Doctor_Rating.pdf')
plot_distribution_with_boxplot(scaled_distribution2, 'Min-Max Scaled Doctor Social Score (Uniform)', 'Min_Max_Scaled_Doctor_Social_Score_Uniform.pdf')
plot_distribution_with_boxplot(scaled_distribution2_normal, 'Min-Max Scaled Doctor Social Score (Normal)', 'Min_Max_Scaled_Doctor_Social_Score_Normal.pdf')
plot_distribution_with_boxplot(standardized_distribution2_normal, 'Z-score Standardized Doctor Social Score (Normal)', 'Z_score_Standardized_Doctor_Social_Score_Normal.pdf')

from scipy.stats import spearmanr

# Compute Spearman correlation between the two distributions
spearman_corr, p_value = spearmanr(scaled_distribution1, scaled_distribution2_skewed)

print("Spearman correlation coefficient:", spearman_corr)
print("p-value:", p_value)

from scipy.stats import wasserstein_distance

# Calculate Wasserstein Distance
w_distance = wasserstein_distance(scaled_distribution1, scaled_distribution2)
print(f'Wasserstein Distance Scaled: {w_distance}')